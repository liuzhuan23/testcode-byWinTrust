<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>XMPP客户端关于Gloox的使用 &mdash; WinTrustIM-Doc 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="WinTrustIM-Doc 0.1 documentation" href="index.html" />
    <link rel="prev" title="OpenFire 我们可以进行什么样的二次开发？" href="openfire_plugin.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>WinTrustIM-Doc 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>XMPP客户端关于Gloox的使用</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="openfire_plugin.html">OpenFire 我们可以进行什么样的二次开发？</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="xmppgloox">
<h1>XMPP客户端关于Gloox的使用<a class="headerlink" href="#xmppgloox" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gloox">
<h2>不再说别的了，直接开始说Gloox怎么用<a class="headerlink" href="#gloox" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>我会按照一个一个的例子来说使用方法，例子就是一个个的应用场景，比如，聊天，群组，发送文件等应用场景</p>
<ul>
<li><p class="first">Gloox的类描述:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>client类                实现IO
connectionlistener类    实现tcp监听
stanza类                实现XMPP响应体描述
registration类          实现注册用户
message类               实现消息流转
rostermanager类         实现花名册
presence类              实现联系人状态
mucroom类               实现会议室
vcard类                 实现用户注册信息修改

所有的类，里面都包含了virtual接口，如果使用了继承，就必须去实现虚接口，实现后，
gloox在你的实现基础之上，还会再次调用他自己的下层实现（virtual）所以，你只需要负责数据业务逻辑就可以了
</pre></div>
</div>
</li>
<li><p class="first">下述为我使用gloox编写代码部署（服务器外网，客户端内网）后，测试过的功能:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>gloox自动支持xmpp ping（XMPP协议：XEP-0199段定义），xmpp动作为：IQ-&gt;Get与IQ-&gt;To，此功能用于保持客户端心跳存活
   1:ping消息可以选择来自服务器的ping
   2:客户端也可以主动发送Ping
   3:gloox允许使用XEP-0199，也就是来自服务器的xml ping，同时自己回复xmp ping保持存活
   4:xmpp 核心协议，RFC6120中定义了whitespace pings，用于保持tcp的ping存活，这个gloox也是支持的，但是从协议上来看，不如XEP-0199直观

gloox设置客户端状态，需要使用xmpp的Presence设置出席状态，实际就是上线，离线，下线，忙碌，还可以表示自己的本机操作动作，比如，在听什么歌

gloox支持客户端定义个性签名（其他个性信息在数据结构中可以自己添加）

gloox支持xmpp注册用户，注册时，支持XMPP的扩展协议，该扩展协议用来表示如下事件 （用户已经存在导致无法注册，用户无法通过格式审核导致注册错误事件通知）

gloox支持xmpp已注册的用户修改自己的密码等注册信息（密码，昵称，头像，地址，Logo，mail，电话）

gloox支持tls/ssl协商，支持自签署的证书，支持如下SASL认证机制方式（DIGEST-MD5，PLAIN，CRAM-MD5，ANONYMOUS）

gloox内网部署代码作为客户端，与外网的服务器，和另外一个内网下的客户端进行通讯，NAT可以穿透，双方可以交互信息

gloox支持添加联系人，联系人如果未确认同意，拒绝消息可以回送给请求一方，如果表示同意，则会有同意消息收到并确认到本地联系人花名册.

gloox支持删除联系人，删除的消息通知可以发送到被删除一方（删除消息也可以不告诉用户，本地收到后不做处理，类似微信）

gloox支持自定义组，好友分组，但仅限于本地，添加联系人的同时，此联系人即可同步到一个组中，该组内的联系人数据可以提供迭代器进行遍历

gloox测试XMPP三种主要消息（Presence，Message，IQ，这三种消息基本描述了XMPP的80%内容），经过测试，都是支持并提供接口进行处理

gloox作为联系人，被添加后，自动同步到xmpp服务器，每一步的操作（添加，删除）都会同步服务器端的数据节点

gloox支持XMPP的HeadLine，也就是类似公告板的消息（新闻，RSS推送），不可回复
   1:点对点的headline消息，属于广播消息，必须设置点对点
   2:群组内的headline消息，属于广播消息，但是必须点对点进行发送，不可直接针对聊天室的id进行发送
   3:利用这个Headline，可以设置为UI公告板
   4:gloox支持Presence的状态推送，比如，如一个联系人发生状态改变，则该Pre值会被推送给所有联系人（该Pre值代表含义需要自己定义），收到后，即可获知联系人在线与否

设置自己的出席状态Presence，通过IO的实现（Client）也可以直接发送，通过gloox的SetPresence是gloox的推荐做法

gloox发送图片方法（1）：把图片经过BASE64进行Encode，再把编码后的字符放入stream中进行发送，也是可以达到图片传送的效果的，经过测试该方法是可行的，唯一缺点：B64编码会增加传输字节

gloox发送语音方法（1）：这个语音不是指的VOIP语音，而是类似微信的那种语音二进制消息，我也是把语音文件进行了BASE64编码，然后放入stream中传递，经过测试该方法是可行的，唯一缺点：B64编码会增加传输字节

gloox实现群组聊天：
   1:群组聊天可以设置自己的群组内状态
   2:设置自己在群组内的昵称
   3:可以实现会议室内的用户群聊（发送与接收信息），通过测试是可以实现的，但是包含以下问题
   4:一个用户发起会议室（我们理解为建立群聊），该聊天室在用户退出后，被服务器取消，不能持久化，需要为每个用户建立一定数量的固定聊天群组在服务器端（这个是可以实现的）
   5:当我们建立用户聊天室持久化后，用户每次退出后，也就是自动退出了聊天室，需要在用户每次登陆时候，发现自己有哪些会议室，并主动加入（xmpp未实现会议室数据同步功能，这点通过改写服务器插件也是可以实现的）
   6:同步的方式，需要在本地存储会议室数据，该数据的获取，来自服务器端改写的插件
   7:群组邀请，gloox存在一处bug，在0.14版本（这是最新的版本了），这个bug导致无法收到群组邀请，现在通过gdb已经找出来了，改掉了

gloox实现XEP-069传输文件：
   1:无法实现非好友的对传文件，双方必须是联系人才可以
   2:聊天室内无法实现对传文件，聊天室也是一个JabberID，这个ID, 无法收文件传送的消息
   3:建议使用http实现，服务器端实现表单和php上传文件，客户端采用curl库，写上传和下载，上传的文件url可以采用uuid命名方式，避免重复

http文件方式实现概述
   1:服务器端运行http服务，并提供html表单和php cig，该表单和cgi结合起来，缓存文件
   2:客户端实现curl库API的调用，文件使用本地uuid方式命名，上传服务器
   3:服务器返回文件缓存url，客户收到消息，将该文件url作为XMPP Message消息发送出去
   4:我这里已经实现了该功能

gloox实现会议室持久话
   1:参考XEP-045
   2:下列为XEP-045中定义的会议室Flag，需要使用gloox的setRoomConfig进行DataFrom的TypeSubmit类型调用（实际是组了一个XML出去）
   &quot;muc#roomconfig_roomname&quot;
   &quot;muc#roomconfig_roomdesc&quot;
   &quot;muc#roomconfig_enablelogging&quot;
   &quot;muc#roomconfig_changesubject&quot;
   &quot;muc#roomconfig_publicroom&quot;
   &quot;muc#roomconfig_persistentroom&quot;
   &quot;muc#roomconfig_moderatedroom&quot;
   &quot;muc#roomconfig_membersonly&quot;
   &quot;muc#roomconfig_passwordprotectedroom&quot;
   &quot;muc#roomconfig_roomsecret&quot;
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="glooxmakefile">
<h2>Gloox实现场景的MakeFile<a class="headerlink" href="#glooxmakefile" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>###############################################################################
#
# Generic Makefile for C/C++ Program
#
# Author: liuzhuan
# Date:   2006/03/04

# Description:
# The makefile searches in &lt;SRCDIRS&gt; directories for the source files
# with extensions specified in &lt;SOURCE_EXT&gt;, then compiles the sources
# and finally produces the &lt;PROGRAM&gt;, the executable file, by linking
# the objectives.

# Usage:
#   $ make           compile and link the program.
#   $ make objs      compile only (no linking. Rarely used).
#   $ make clean     clean the objectives and dependencies.
#   $ make cleanall  clean the objectives, dependencies and executable.
#   $ make rebuild   rebuild the program. The same as make clean &amp;&amp; make all.
#==============================================================================

## Customizing Section: adjust the following if necessary.
##=============================================================================

# The executable file name.
# It must be specified.
# PROGRAM   := a.out    # the executable name
PROGRAM   := testgl

# The directories in which source files reside.
# At least one path should be specified.
# SRCDIRS   := .        # current directory
SRCDIRS   := .

# The source file types (headers excluded).
# At least one type should be specified.
# The valid suffixes are among of .c, .C, .cc, .cpp, .CPP, .c++, .cp, or .cxx.
# SRCEXTS   := .c      # C program
# SRCEXTS   := .cpp    # C++ program
# SRCEXTS   := .c .cpp # C/C++ program
SRCEXTS   := .cpp

# The flags used by the cpp (man cpp for more).
# CPPFLAGS  := -Wall -Werror # show all warnings and take them as errors
CPPFLAGS  :=

# The compiling flags used only for C.
# If it is a C++ program, no need to set these flags.
# If it is a C and C++ merging program, set these flags for the C parts.
# mysql_config --cflags
CFLAGS    := -g -O0
CFLAGS    += -I/usr/local/include

# The compiling flags used only for C++.
# If it is a C program, no need to set these flags.
# If it is a C and C++ merging program, set these flags for the C++ parts.
CXXFLAGS  := -g -O0
CXXFLAGS  += -I/usr/local/include

# The library and the link options ( C and C++ common).
# mysql_config --libs
LDFLAGS   := 
LDFLAGS   += -L/usr/local/lib -lresolv -lidn -lz -lgloox -lssl -lpthread

## Implict Section: change the following only when necessary.
##=============================================================================
# The C program compiler. Uncomment it to specify yours explicitly.
CC      = gcc

# The C++ program compiler. Uncomment it to specify yours explicitly.
#CXX     = g++

# Uncomment the 2 lines to compile C programs as C++ ones.
#CC      = $(CXX)
#CFLAGS  = $(CXXFLAGS)

# The command used to delete file.
#RM        = rm -f

## Stable Section: usually no need to be changed. But you can add more.
##=============================================================================
SHELL   = /bin/sh
SOURCES = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)/*,$(SRCEXTS))))
OBJS    = $(foreach x,$(SRCEXTS), \
      $(patsubst %$(x),%.o,$(filter %$(x),$(SOURCES))))
DEPS    = $(patsubst %.o,%.d,$(OBJS))

.PHONY : all objs clean cleanall rebuild

all : $(PROGRAM)

# Rules for creating the dependency files (.d).
#---------------------------------------------------
%.d : %.c
	@$(CC) -MM -MD $(CFLAGS) $&lt;

%.d : %.C
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.cc
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.cpp
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.CPP
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.c++
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.cp
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

%.d : %.cxx
	@$(CC) -MM -MD $(CXXFLAGS) $&lt;

# Rules for producing the objects.
#---------------------------------------------------
objs : $(OBJS)

%.o : %.c
	$(CC) -c $(CPPFLAGS) $(CFLAGS) $&lt;

%.o : %.C
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.cc
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.cpp
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.CPP
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.c++
	$(CXX -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.cp
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

%.o : %.cxx
	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;

# Rules for producing the executable.
#----------------------------------------------
$(PROGRAM) : $(OBJS)
ifeq ($(strip $(SRCEXTS)), .c)  # C file
	$(CC) -o $(PROGRAM) $(OBJS) $(LDFLAGS)
else                            # C++ file
	$(CXX) -o $(PROGRAM) $(OBJS) $(LDFLAGS)
endif

-include $(DEPS)

rebuild: clean all

clean :
	@$(RM) *.o *.d $(PROGRAM)

cleanall: clean
	@$(RM) $(PROGRAM) $(PROGRAM).exe

### End of the Makefile ##  Suggestions are welcome  ## All rights reserved ###
##############################################################################
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="gloox-openfire">
<h2>Gloox实现场景-登录进去openfire<a class="headerlink" href="#gloox-openfire" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;gloox/gloox.h&quot;
#include &quot;gloox/client.h&quot;
#include &quot;gloox/connectionlistener.h&quot;
#include &quot;gloox/connectiontls.h&quot;
#include &quot;gloox/connectiontlsserver.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/disco.h&quot;
#include &quot;gloox/discohandler.h&quot;
#include &quot;gloox/stanza.h&quot;
#include &quot;gloox/lastactivity.h&quot;
#include &quot;gloox/registration.h&quot;
#include &quot;gloox/logsink.h&quot;
#include &quot;gloox/loghandler.h&quot;

//这部分头文件是关于聊天和注册的
#include &quot;gloox/message.h&quot;
#include &quot;gloox/messagehandler.h&quot;
#include &quot;gloox/messagesessionhandler.h&quot;
#include &quot;gloox/messageeventhandler.h&quot;
#include &quot;gloox/messageeventfilter.h&quot;
#include &quot;gloox/chatstatehandler.h&quot;
#include &quot;gloox/chatstatefilter.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/connectionsocks5proxy.h&quot;
#include &quot;gloox/connectionhttpproxy.h&quot;

//这部分头文件是关于花名册和设置状态，签名（上线，下线，离开等）
#include &quot;gloox/rostermanager.h&quot;
#include &quot;gloox/presence.h&quot;

//这部分头文件是关于会议室的（群组）
#include &quot;gloox/mucroom.h&quot;
#include &quot;gloox/mucroomhandler.h&quot;
#include &quot;gloox/mucinvitationhandler.h&quot;

//这部分头文件是关于修改自己注册信息的
#include &quot;gloox/vcardhandler.h&quot;
#include &quot;gloox/vcardmanager.h&quot;
#include &quot;gloox/vcard.h&quot;

//这部分头文件是关于实现XEP-069扩展
#include &quot;gloox/siprofileft.h&quot;
#include &quot;gloox/siprofilefthandler.h&quot;
#include &quot;gloox/bytestreamdatahandler.h&quot;
#include &quot;gloox/socks5bytestreamserver.h&quot;

#include &quot;gloox/dataform.h&quot;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

//没用其他的数据结构，这里只用了两个命名空间，std和gloox
using namespace std;
using namespace gloox;

class MessageTest : RosterListener, MessageSessionHandler, ConnectionListener, MessageEventHandler, MessageHandler, ChatStateHandler, LogHandler
{
    public:
        MessageTest() : m_session( 0 ), m_messageEventFilter( 0 ), m_chatStateFilter( 0 ) {}

        virtual ~MessageTest() {}

        void start()
        {
            JID jid( &quot;ca23@192.168.199.225/ca23&quot; );
            j = new Client( jid, &quot;123456&quot; );
            j-&gt;registerConnectionListener( this ); //注册client的recv
            j-&gt;registerMessageSessionHandler( this, 0 ); //注册会话等类
            j-&gt;rosterManager()-&gt;registerRosterListener( this ); //注册花名册管理
            j-&gt;disco()-&gt;setVersion( &quot;messageTest&quot;, gloox::GLOOX_VERSION, &quot;Linux&quot; ); //设置版本
            j-&gt;disco()-&gt;setIdentity( &quot;client&quot;, &quot;bot&quot; ); //设置XMPP实体（一个XML概念）
            j-&gt;disco()-&gt;addFeature( gloox::XMLNS_CHAT_STATES );
            j-&gt;logInstance().registerLogHandler( LogLevelDebug, LogAreaAll, this ); //打开LOG
            j-&gt;setPresence( Presence::Chat, 1, &quot;Play Music WoWo-Gala!&quot; ); //设置自己的状态还有在签名
            
            if( j-&gt;connect( false ) )
            {
                ConnectionError ce = ConnNoError;
                while( ce == ConnNoError )
                {
                    ce = j-&gt;recv();
                }
                printf( &quot;ce: %d\n&quot;, ce );
            }
            
            delete( j );
        }
        
        virtual void onConnect()
        {
            printf( &quot;connected!!!\n&quot; );
        }

        virtual void onDisconnect( ConnectionError e )
        {
            printf( &quot;message_test: disconnected: %d\n&quot;, e );
            if( e == ConnAuthenticationFailed ) printf( &quot;auth failed. reason: %d\n&quot;, j-&gt;authError() );
        }

        virtual bool onTLSConnect( const CertInfo&amp; info )
        {
            time_t from( info.date_from );
            time_t to( info.date_to );
            printf( &quot;status: %d\nissuer: %s\npeer: %s\nprotocol: %s\nmac: %s\ncipher: %s\ncompression: %s\n&quot; &quot;from: %s\nto: %s\n&quot;, info.status, info.issuer.c_str(), info.server.c_str(), info.protocol.c_str(), info.mac.c_str(), info.cipher.c_str(), info.compression.c_str(), ctime( &amp;from ), ctime( &amp;to ) );
            return true;
        }

    private:
        Client * j;
        MessageSession * m_session;
        MessageEventFilter * m_messageEventFilter;
        ChatStateFilter * m_chatStateFilter;
        MucTest * mt;
};

int main( int argc, char* argv[] )
{
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}

</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="gloox-xmpp">
<h2>Gloox实现场景-XMPP加好友<a class="headerlink" href="#gloox-xmpp" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;gloox/gloox.h&quot;
#include &quot;gloox/client.h&quot;
#include &quot;gloox/connectionlistener.h&quot;
#include &quot;gloox/connectiontls.h&quot;
#include &quot;gloox/connectiontlsserver.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/disco.h&quot;
#include &quot;gloox/discohandler.h&quot;
#include &quot;gloox/stanza.h&quot;
#include &quot;gloox/lastactivity.h&quot;
#include &quot;gloox/registration.h&quot;
#include &quot;gloox/logsink.h&quot;
#include &quot;gloox/loghandler.h&quot;

//这部分头文件是关于聊天和注册的
#include &quot;gloox/message.h&quot;
#include &quot;gloox/messagehandler.h&quot;
#include &quot;gloox/messagesessionhandler.h&quot;
#include &quot;gloox/messageeventhandler.h&quot;
#include &quot;gloox/messageeventfilter.h&quot;
#include &quot;gloox/chatstatehandler.h&quot;
#include &quot;gloox/chatstatefilter.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/connectionsocks5proxy.h&quot;
#include &quot;gloox/connectionhttpproxy.h&quot;

//这部分头文件是关于花名册和设置状态，签名（上线，下线，离开等）
#include &quot;gloox/rostermanager.h&quot;
#include &quot;gloox/presence.h&quot;

//这部分头文件是关于会议室的（群组）
#include &quot;gloox/mucroom.h&quot;
#include &quot;gloox/mucroomhandler.h&quot;
#include &quot;gloox/mucinvitationhandler.h&quot;

//这部分头文件是关于修改自己注册信息的
#include &quot;gloox/vcardhandler.h&quot;
#include &quot;gloox/vcardmanager.h&quot;
#include &quot;gloox/vcard.h&quot;

//这部分头文件是关于实现XEP-069扩展
#include &quot;gloox/siprofileft.h&quot;
#include &quot;gloox/siprofilefthandler.h&quot;
#include &quot;gloox/bytestreamdatahandler.h&quot;
#include &quot;gloox/socks5bytestreamserver.h&quot;

#include &quot;gloox/dataform.h&quot;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

//没用其他的数据结构，这里只用了两个命名空间，std和gloox
using namespace std;
using namespace gloox;

//*******************************************************
//gloox一旦实现了继承类，就必须实现这些继承类的virtual接口
//有些接口必须注册（IO里用来通知消息给该接口）
//有的接口则不用注册，在gloox流程分支中会自动触发
//这个功能的实现，主要依靠virtual interface:
//     &quot;handleSubscriptionRequest&quot;
//并注意：该接口原先有BUG，我修改了后可以使用，具体修改原因
//请具体的参考gloox的代码
//*******************************************************

//*******************************************************
//添加联系人分为接受邀请，和发出邀请
//接受邀请分成了四个事件，分别为：
// &quot;handleSubscriptionRequest&quot;   收到邀请（原先代码有BUG，导致不能收到邀请，这个函数是修改后的版本）
// &quot;handleItemAdded&quot;             发生添加
// &quot;handleItemUpdated&quot;           花名册发生更新
// &quot;handleItemSubscribed&quot;        好友的出席状态
//按照理解，只需要处理邀请通知，和好友的出席状态通知即可
//*******************************************************

//*******************************************************
//发送邀请
//假设这是一个按钮点击后触发的代码，请求添加好友op23，他的组为Test-Group-Name
//.......
//调用add会同步联系人到远端，本地也有添加，但是通知不会告知给被添加一方，除非调用subscribe发起通知，对端才会收到请求
//StringList groups;
//groups.push_back(&quot;Test-Group-Name&quot;);
//j-&gt;rosterManager()-&gt;add( JID( &quot;op23@192.168.199.225&quot; ), &quot;op23&quot;, groups ); 
//如果你调用subscribe发起通知，则对端会收到请求
//j-&gt;rosterManager()-&gt;subscribe( JID(  ) );
//*******************************************************

//*******************************************************
//接触好友关系收到，主要分为3个事件
// &quot;handleItemUnsubscribed&quot;
// &quot;handleItemUpdated&quot;
// &quot;handleItemRemoved&quot;
//按照理解，分别为解除出席，花名册更新，花名册移除
//*******************************************************
class MessageTest : RosterListener, MessageSessionHandler, ConnectionListener, MessageEventHandler, MessageHandler, ChatStateHandler, LogHandler
{
    public:
        MessageTest() : m_session( 0 ), m_messageEventFilter( 0 ), m_chatStateFilter( 0 ) {}

        virtual ~MessageTest() {}

        void start()
        {
            JID jid( &quot;ca23@192.168.199.225/ca23&quot; );
            j = new Client( jid, &quot;123456&quot; );
            j-&gt;registerConnectionListener( this ); //注册client的recv
            j-&gt;registerMessageSessionHandler( this, 0 ); //注册会话等类
            j-&gt;rosterManager()-&gt;registerRosterListener( this ); //注册花名册管理
            j-&gt;disco()-&gt;setVersion( &quot;messageTest&quot;, gloox::GLOOX_VERSION, &quot;Linux&quot; ); //设置版本
            j-&gt;disco()-&gt;setIdentity( &quot;client&quot;, &quot;bot&quot; ); //设置XMPP实体（一个XML概念）
            j-&gt;disco()-&gt;addFeature( gloox::XMLNS_CHAT_STATES );
            j-&gt;logInstance().registerLogHandler( LogLevelDebug, LogAreaAll, this ); //打开LOG
            j-&gt;setPresence( Presence::Chat, 1, &quot;Play Music WoWo-Gala!&quot; ); //设置自己的状态还有在签名
            
            if( j-&gt;connect( false ) )
            {
                ConnectionError ce = ConnNoError;
                while( ce == ConnNoError )
                {
                    ce = j-&gt;recv();
                }
                printf( &quot;ce: %d\n&quot;, ce );
            }
            
            delete( j );
        }
        
        virtual void onConnect()
        {
            printf( &quot;connected!!!\n&quot; );
        }

        virtual void onDisconnect( ConnectionError e )
        {
            printf( &quot;message_test: disconnected: %d\n&quot;, e );
            if( e == ConnAuthenticationFailed ) printf( &quot;auth failed. reason: %d\n&quot;, j-&gt;authError() );
        }

        virtual bool onTLSConnect( const CertInfo&amp; info )
        {
            time_t from( info.date_from );
            time_t to( info.date_to );
            printf( &quot;status: %d\nissuer: %s\npeer: %s\nprotocol: %s\nmac: %s\ncipher: %s\ncompression: %s\n&quot; &quot;from: %s\nto: %s\n&quot;, info.status, info.issuer.c_str(), info.server.c_str(), info.protocol.c_str(), info.mac.c_str(), info.cipher.c_str(), info.compression.c_str(), ctime( &amp;from ), ctime( &amp;to ) );
            return true;
        }

        virtual void handleMessageSession( MessageSession *session )
        {
            printf( &quot;got new session\n&quot;);
            if( m_session ) j-&gt;disposeMessageSession( m_session );
            m_session = session;
            m_session-&gt;registerMessageHandler( this );
            m_messageEventFilter = new MessageEventFilter( m_session );
            m_messageEventFilter-&gt;registerMessageEventHandler( this );
            m_chatStateFilter = new ChatStateFilter( m_session );
            m_chatStateFilter-&gt;registerChatStateHandler( this );
        }
        
        //log输出事件，这个事件，在gloox流程中，很多地方都会触发，所以，log信息量会比较大
        virtual void handleLog( LogLevel level, LogArea area, const std::string&amp; message )
        {
            printf(&quot;#-----------#  log: level: %d, area: %d, %s\n&quot;, level, area, message.c_str() );
        }
        
        virtual void handleItemSubscribed( const JID&amp; jid ) 
        {
            printf( &quot;subscribed %s\n&quot;, jid.bare().c_str() );
        }

        virtual void handleItemAdded( const JID&amp; jid )
        {
            printf( &quot;added %s\n&quot;, jid.bare().c_str() );
        }

        virtual void handleItemUnsubscribed( const JID&amp; jid )
        {
            printf( &quot;unsubscribed %s\n&quot;, jid.bare().c_str() );
        }

        virtual void handleItemRemoved( const JID&amp; jid )
        {
            printf( &quot;removed %s\n&quot;, jid.bare().c_str() );
        }

        virtual void handleItemUpdated( const JID&amp; jid )
        {
            printf( &quot;updated %s\n&quot;, jid.bare().c_str() );
        }

        virtual bool handleSubscriptionRequest( const JID&amp; jid, const std::string&amp; /*msg*/ )
        {
            //ack {false, true} {拒绝联系人请求，同意联系人请求}
            bool ack = true;
                        
            printf( &quot;subscription: %s\n&quot;, jid.bare().c_str() );
            
            //建立一个组为Test-Group-Name
            StringList groups;
            groups.push_back(&quot;Test-Group-Name&quot;);
            JID id( jid );
            
            //添加到了本地花名册，加入的组为Test-Group-Name
            j-&gt;rosterManager()-&gt;subscribe( id, &quot;&quot;, groups, &quot;&quot; );
            
            return ack;
        }

    private:
        Client * j;
        MessageSession * m_session;
        MessageEventFilter * m_messageEventFilter;
        ChatStateFilter * m_chatStateFilter;
        MucTest * mt;
};


int main( int argc, char* argv[] )
{
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id1">
<h2>Gloox实现场景-XMPP对话<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;gloox/gloox.h&quot;
#include &quot;gloox/client.h&quot;
#include &quot;gloox/connectionlistener.h&quot;
#include &quot;gloox/connectiontls.h&quot;
#include &quot;gloox/connectiontlsserver.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/disco.h&quot;
#include &quot;gloox/discohandler.h&quot;
#include &quot;gloox/stanza.h&quot;
#include &quot;gloox/lastactivity.h&quot;
#include &quot;gloox/registration.h&quot;
#include &quot;gloox/logsink.h&quot;
#include &quot;gloox/loghandler.h&quot;

//这部分头文件是关于聊天和注册的
#include &quot;gloox/message.h&quot;
#include &quot;gloox/messagehandler.h&quot;
#include &quot;gloox/messagesessionhandler.h&quot;
#include &quot;gloox/messageeventhandler.h&quot;
#include &quot;gloox/messageeventfilter.h&quot;
#include &quot;gloox/chatstatehandler.h&quot;
#include &quot;gloox/chatstatefilter.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/connectionsocks5proxy.h&quot;
#include &quot;gloox/connectionhttpproxy.h&quot;

//这部分头文件是关于花名册和设置状态，签名（上线，下线，离开等）
#include &quot;gloox/rostermanager.h&quot;
#include &quot;gloox/presence.h&quot;

//这部分头文件是关于会议室的（群组）
#include &quot;gloox/mucroom.h&quot;
#include &quot;gloox/mucroomhandler.h&quot;
#include &quot;gloox/mucinvitationhandler.h&quot;

//这部分头文件是关于修改自己注册信息的
#include &quot;gloox/vcardhandler.h&quot;
#include &quot;gloox/vcardmanager.h&quot;
#include &quot;gloox/vcard.h&quot;

//这部分头文件是关于实现XEP-069扩展
#include &quot;gloox/siprofileft.h&quot;
#include &quot;gloox/siprofilefthandler.h&quot;
#include &quot;gloox/bytestreamdatahandler.h&quot;
#include &quot;gloox/socks5bytestreamserver.h&quot;

#include &quot;gloox/dataform.h&quot;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

//没用其他的数据结构，这里只用了两个命名空间，std和gloox
using namespace std;
using namespace gloox;

//*******************************************************
//gloox一旦实现了继承类，就必须实现这些继承类的virtual接口
//有些接口必须注册（IO里用来通知消息给该接口）
//有的接口则不用注册，在gloox流程分支中会自动触发
//*******************************************************

//*******************************************************
//主要实现对话的virtual interface 
//    &quot;handleMessage&quot;
//在这里，可以收到任何的对话消息，记住，是任何的！
//所以，我们可以利用这个设计，来增加一个xmpp subject类型，表示为语音或者文件消息，
//这个设计在后文中会见到
//*******************************************************

//*******************************************************
//同时需要特别注意对话中的另外一个virtual interface 
//    &quot;handleRosterPresence
//他负责接收好友的出席状态变化，在这里，收到出席状态后，你可以标记出来，很方便
//*******************************************************
class MessageTest : RosterListener, MessageSessionHandler, ConnectionListener, MessageEventHandler, MessageHandler, ChatStateHandler, LogHandler
{
    public:
        MessageTest() : m_session( 0 ), m_messageEventFilter( 0 ), m_chatStateFilter( 0 ) {}

        virtual ~MessageTest() {}

        void start()
        {
            JID jid( &quot;ca23@192.168.199.225/ca23&quot; );
            j = new Client( jid, &quot;123456&quot; );
            j-&gt;registerConnectionListener( this ); //注册client的recv
            j-&gt;registerMessageSessionHandler( this, 0 ); //注册会话等类
            j-&gt;rosterManager()-&gt;registerRosterListener( this ); //注册花名册管理
            j-&gt;disco()-&gt;setVersion( &quot;messageTest&quot;, gloox::GLOOX_VERSION, &quot;Linux&quot; ); //设置版本
            j-&gt;disco()-&gt;setIdentity( &quot;client&quot;, &quot;bot&quot; ); //设置XMPP实体（一个XML概念）
            j-&gt;disco()-&gt;addFeature( gloox::XMLNS_CHAT_STATES );
            j-&gt;logInstance().registerLogHandler( LogLevelDebug, LogAreaAll, this ); //打开LOG
            j-&gt;setPresence( Presence::Chat, 1, &quot;Play Music WoWo-Gala!&quot; ); //设置自己的状态还有在签名
            
            if( j-&gt;connect( false ) )
            {
                ConnectionError ce = ConnNoError;
                while( ce == ConnNoError )
                {
                    ce = j-&gt;recv();
                }
                printf( &quot;ce: %d\n&quot;, ce );
            }
            
            delete( j );
        }
        
        virtual void onConnect()
        {
            printf( &quot;connected!!!\n&quot; );
        }

        virtual void onDisconnect( ConnectionError e )
        {
            printf( &quot;message_test: disconnected: %d\n&quot;, e );
            if( e == ConnAuthenticationFailed ) printf( &quot;auth failed. reason: %d\n&quot;, j-&gt;authError() );
        }

        virtual bool onTLSConnect( const CertInfo&amp; info )
        {
            time_t from( info.date_from );
            time_t to( info.date_to );
            printf( &quot;status: %d\nissuer: %s\npeer: %s\nprotocol: %s\nmac: %s\ncipher: %s\ncompression: %s\n&quot; &quot;from: %s\nto: %s\n&quot;, info.status, info.issuer.c_str(), info.server.c_str(), info.protocol.c_str(), info.mac.c_str(), info.cipher.c_str(), info.compression.c_str(), ctime( &amp;from ), ctime( &amp;to ) );
            return true;
        }

        virtual void handleMessage( const Message &amp; msg, MessageSession * session)
        {
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventDisplayed );
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventComposing );
            m_chatStateFilter-&gt;setChatState( ChatStateComposing );
                        
            //message body消息体判断，这里判断的原因是 virtusl 实现 handleMessage 句柄后，所有的涉及到
            //xmpp message结构消息的内容都会流经此处
            if( msg.subtype() == Message::Chat )
            {
                if( msg.body().length() == 0 )
                {
                    return;
                }
                else
                {
                    printf( &quot;type: %d, subject: %s, message: %s, thread id: %s, from: %s\n&quot;, msg.subtype(), msg.subject().c_str(), msg.body().c_str(), msg.thread().c_str(), msg.from().full().c_str() );
                }
            }
        }

        virtual void handleMessageEvent( const JID&amp; from, MessageEventType event )
        {
            printf( &quot;received event: %d from: %s\n&quot;, event, from.full().c_str() );
        }

        virtual void handleChatState( const JID&amp; from, ChatStateType state )
        {
            printf( &quot;received state: %d from: %s\n&quot;, state, from.full().c_str() );
        }

        virtual void handleMessageSession( MessageSession *session )
        {
            printf( &quot;got new session\n&quot;);
            if( m_session ) j-&gt;disposeMessageSession( m_session );
            m_session = session;
            m_session-&gt;registerMessageHandler( this );
            m_messageEventFilter = new MessageEventFilter( m_session );
            m_messageEventFilter-&gt;registerMessageEventHandler( this );
            m_chatStateFilter = new ChatStateFilter( m_session );
            m_chatStateFilter-&gt;registerChatStateHandler( this );
        }
        
        //log输出事件，这个事件，在gloox流程中，很多地方都会触发，所以，log信息量会比较大
        virtual void handleLog( LogLevel level, LogArea area, const std::string&amp; message )
        {
            printf(&quot;#-----------#  log: level: %d, area: %d, %s\n&quot;, level, area, message.c_str() );
        }
        
        virtual void onResourceBindError( ResourceBindError error )
        {
            printf( &quot;onResourceBindError: %d\n&quot;, error );
        }

        virtual void onSessionCreateError( SessionCreateError error )
        {
            printf( &quot;onSessionCreateError: %d\n&quot;, error );
        }

        //出席事件状态通知，从这里可以得到联系人的状态改变，从而标记联系人变化
        virtual void handleRosterPresence( const RosterItem&amp; item, const std::string&amp; resource, Presence::PresenceType presence, const std::string&amp; /*msg*/ )
        {
            printf( &quot;presence received: %s/%s -- %d\n&quot;, item.jidJID().full().c_str(), resource.c_str(), presence );
        }

        virtual void handleSelfPresence( const RosterItem&amp; item, const std::string&amp; resource, Presence::PresenceType presence, const std::string&amp; /*msg*/ )
        {
            printf( &quot;self presence received: %s/%s -- %d\n&quot;, item.jidJID().full().c_str(), resource.c_str(), presence );
        }

    private:
        Client * j;
        MessageSession * m_session;
        MessageEventFilter * m_messageEventFilter;
        ChatStateFilter * m_chatStateFilter;
        MucTest * mt;
};

int main( int argc, char* argv[] )
{
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id2">
<h2>Gloox实现场景-文件传输<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>//*******************************************************
//gloox一旦实现了继承类，就必须实现这些继承类的virtual接口
//有些接口必须注册（IO里用来通知消息给该接口）
//有的接口则不用注册，在gloox流程分支中会自动触发
//*******************************************************

//*******************************************************
//文件传输，建议使用http方式
//在消息体中，表明为文件类型的消息，收到后，处理文件
//文件的发送与接收，都使用htpp
//*******************************************************

class MessageTest : RosterListener, MessageSessionHandler, ConnectionListener, MessageEventHandler, MessageHandler, ChatStateHandler, LogHandler
{
    public:
        MessageTest() : m_session( 0 ), m_messageEventFilter( 0 ), m_chatStateFilter( 0 ) {}

        virtual ~MessageTest() {}

        void start()
        {
            JID jid( &quot;ca23@192.168.199.225/ca23&quot; );
            j = new Client( jid, &quot;123456&quot; );
            j-&gt;registerConnectionListener( this ); //注册client的recv
            j-&gt;registerMessageSessionHandler( this, 0 ); //注册会话等类
            j-&gt;rosterManager()-&gt;registerRosterListener( this ); //注册花名册管理
            j-&gt;disco()-&gt;setVersion( &quot;messageTest&quot;, gloox::GLOOX_VERSION, &quot;Linux&quot; ); //设置版本
            j-&gt;disco()-&gt;setIdentity( &quot;client&quot;, &quot;bot&quot; ); //设置XMPP实体（一个XML概念）
            j-&gt;disco()-&gt;addFeature( gloox::XMLNS_CHAT_STATES );
            j-&gt;logInstance().registerLogHandler( LogLevelDebug, LogAreaAll, this ); //打开LOG
            j-&gt;setPresence( Presence::Chat, 1, &quot;Play Music WoWo-Gala!&quot; ); //设置自己的状态还有在签名
            
            if( j-&gt;connect( false ) )
            {
                ConnectionError ce = ConnNoError;
                while( ce == ConnNoError )
                {
                    ce = j-&gt;recv();
                }
                printf( &quot;ce: %d\n&quot;, ce );
            }
            
            delete( j );
        }
        
        virtual void onConnect()
        {
            printf( &quot;connected!!!\n&quot; );
        }

        virtual void onDisconnect( ConnectionError e )
        {
            printf( &quot;message_test: disconnected: %d\n&quot;, e );
            if( e == ConnAuthenticationFailed ) printf( &quot;auth failed. reason: %d\n&quot;, j-&gt;authError() );
        }

        virtual bool onTLSConnect( const CertInfo&amp; info )
        {
            time_t from( info.date_from );
            time_t to( info.date_to );
            printf( &quot;status: %d\nissuer: %s\npeer: %s\nprotocol: %s\nmac: %s\ncipher: %s\ncompression: %s\n&quot; &quot;from: %s\nto: %s\n&quot;, info.status, info.issuer.c_str(), info.server.c_str(), info.protocol.c_str(), info.mac.c_str(), info.cipher.c_str(), info.compression.c_str(), ctime( &amp;from ), ctime( &amp;to ) );
            return true;
        }

        virtual void handleMessage( const Message &amp; msg, MessageSession * session)
        {
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventDisplayed );
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventComposing );
            m_chatStateFilter-&gt;setChatState( ChatStateComposing );
            
            //这里的消息命令。都是自己定义的，用来测试的
            //因为是消息机制，所以，用消息代表一个命令，发过来触发流程操作
            if( msg.body() == &quot;test-file-trans-command&quot; )
            {
                //确认为文件消息后
                //开始使用http进行下载文件
            }
            else if( msg.body() == &quot;test-voice-trans-command&quot; )
            {

            }
            else
            {
                //message body消息体判断，这里判断的原因是 virtusl 实现 handleMessage 句柄后，所有的涉及到
                //xmpp message结构消息的内容都会流经此处，所以，需要过滤一下
                if( msg.subtype() == Message::Chat )
                {
                    if( msg.body().length() == 0 )
                    {
                        return;
                    }
                    else
                    {
                        printf( &quot;type: %d, subject: %s, message: %s, thread id: %s, from: %s\n&quot;, msg.subtype(), msg.subject().c_str(), msg.body().c_str(), msg.thread().c_str(), msg.from().full().c_str() );
                    }
                }
            }
        }

        virtual void handleMessageEvent( const JID&amp; from, MessageEventType event )
        {
            printf( &quot;received event: %d from: %s\n&quot;, event, from.full().c_str() );
        }

        virtual void handleChatState( const JID&amp; from, ChatStateType state )
        {
            printf( &quot;received state: %d from: %s\n&quot;, state, from.full().c_str() );
        }

        virtual void handleMessageSession( MessageSession *session )
        {
            printf( &quot;got new session\n&quot;);
            if( m_session ) j-&gt;disposeMessageSession( m_session );
            m_session = session;
            m_session-&gt;registerMessageHandler( this );
            m_messageEventFilter = new MessageEventFilter( m_session );
            m_messageEventFilter-&gt;registerMessageEventHandler( this );
            m_chatStateFilter = new ChatStateFilter( m_session );
            m_chatStateFilter-&gt;registerChatStateHandler( this );
        }
        
        //log输出事件，这个事件，在gloox流程中，很多地方都会触发，所以，log信息量会比较大
        virtual void handleLog( LogLevel level, LogArea area, const std::string&amp; message )
        {
            printf(&quot;#-----------#  log: level: %d, area: %d, %s\n&quot;, level, area, message.c_str() );
        }
        
        virtual void onResourceBindError( ResourceBindError error )
        {
            printf( &quot;onResourceBindError: %d\n&quot;, error );
        }

        virtual void onSessionCreateError( SessionCreateError error )
        {
            printf( &quot;onSessionCreateError: %d\n&quot;, error );
        }

    private:
        Client * j;
        MessageSession * m_session;
        MessageEventFilter * m_messageEventFilter;
        ChatStateFilter * m_chatStateFilter;
        MucTest * mt;
};

int main( int argc, char* argv[] )
{
    //测试消息，包括聊天室，文件传输，语音消息，图片等，具体参考消息命令
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}

</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id3">
<h2>Gloox实现场景-语音传输<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>//*******************************************************
//gloox一旦实现了继承类，就必须实现这些继承类的virtual接口
//有些接口必须注册（IO里用来通知消息给该接口）
//有的接口则不用注册，在gloox流程分支中会自动触发
//*******************************************************

//*******************************************************
//语音类型的消息，建议使用base64编码进行传输
//到达目的地后，进行解码，解码后，进行播放
//*******************************************************

class MessageTest : RosterListener, MessageSessionHandler, ConnectionListener, MessageEventHandler, MessageHandler, ChatStateHandler, LogHandler
{
    public:
        MessageTest() : m_session( 0 ), m_messageEventFilter( 0 ), m_chatStateFilter( 0 ) {}

        virtual ~MessageTest() {}

        void start()
        {
            JID jid( &quot;ca23@192.168.199.225/ca23&quot; );
            j = new Client( jid, &quot;123456&quot; );
            j-&gt;registerConnectionListener( this ); //注册client的recv
            j-&gt;registerMessageSessionHandler( this, 0 ); //注册会话等类
            j-&gt;rosterManager()-&gt;registerRosterListener( this ); //注册花名册管理
            j-&gt;disco()-&gt;setVersion( &quot;messageTest&quot;, gloox::GLOOX_VERSION, &quot;Linux&quot; ); //设置版本
            j-&gt;disco()-&gt;setIdentity( &quot;client&quot;, &quot;bot&quot; ); //设置XMPP实体（一个XML概念）
            j-&gt;disco()-&gt;addFeature( gloox::XMLNS_CHAT_STATES );
            j-&gt;logInstance().registerLogHandler( LogLevelDebug, LogAreaAll, this ); //打开LOG
            j-&gt;setPresence( Presence::Chat, 1, &quot;Play Music WoWo-Gala!&quot; ); //设置自己的状态还有在签名
            
            if( j-&gt;connect( false ) )
            {
                ConnectionError ce = ConnNoError;
                while( ce == ConnNoError )
                {
                    ce = j-&gt;recv();
                }
                printf( &quot;ce: %d\n&quot;, ce );
            }
            
            delete( j );
        }
        
        virtual void onConnect()
        {
            printf( &quot;connected!!!\n&quot; );
        }

        virtual void onDisconnect( ConnectionError e )
        {
            printf( &quot;message_test: disconnected: %d\n&quot;, e );
            if( e == ConnAuthenticationFailed ) printf( &quot;auth failed. reason: %d\n&quot;, j-&gt;authError() );
        }

        virtual bool onTLSConnect( const CertInfo&amp; info )
        {
            time_t from( info.date_from );
            time_t to( info.date_to );
            printf( &quot;status: %d\nissuer: %s\npeer: %s\nprotocol: %s\nmac: %s\ncipher: %s\ncompression: %s\n&quot; &quot;from: %s\nto: %s\n&quot;, info.status, info.issuer.c_str(), info.server.c_str(), info.protocol.c_str(), info.mac.c_str(), info.cipher.c_str(), info.compression.c_str(), ctime( &amp;from ), ctime( &amp;to ) );
            return true;
        }

        virtual void handleMessage( const Message &amp; msg, MessageSession * session)
        {
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventDisplayed );
            m_messageEventFilter-&gt;raiseMessageEvent( MessageEventComposing );
            m_chatStateFilter-&gt;setChatState( ChatStateComposing );
            
            //这里的消息命令。都是自己定义的，用来测试的
            //因为是消息机制，所以，用消息代表一个命令，发过来触发流程操作
            if( msg.body() == &quot;test-file-trans-command&quot; )
            {

            }
            else if( msg.body() == &quot;test-voice-trans-command&quot; )
            {
                 //测试二进制数据，我这里使用了一个B64编码的文件，
                //该文件经过了BASE64编码，原先为一个图片
                /*
                MessageType
                Chat 	     A chat message.
                Error 	     An error message.
                Groupchat 	 A groupchat message.
                Headline 	 A headline message.
                Normal 	     A normal message.
                Invalid 	 The message stanza is invalid. 
                */
                std::ifstream in(&quot;input.txt&quot;, ios::in);
                std::istreambuf_iterator&lt;char&gt; beg(in), end;
                std::string strdata(beg, end);
                in.close();
                std::string subject = &quot;VOICE&quot;;
                m_session-&gt;send( strdata, subject );
            }
            else
            {
                //message body消息体判断，这里判断的原因是 virtusl 实现 handleMessage 句柄后，所有的涉及到
                //xmpp message结构消息的内容都会流经此处，所以，需要过滤一下
                if( msg.subtype() == Message::Chat )
                {
                    if( msg.body().length() == 0 )
                    {
                        return;
                    }
                    else
                    {
                        printf( &quot;type: %d, subject: %s, message: %s, thread id: %s, from: %s\n&quot;, msg.subtype(), msg.subject().c_str(), msg.body().c_str(), msg.thread().c_str(), msg.from().full().c_str() );
                    }
                }
            }
        }

        virtual void handleMessageEvent( const JID&amp; from, MessageEventType event )
        {
            printf( &quot;received event: %d from: %s\n&quot;, event, from.full().c_str() );
        }

        virtual void handleChatState( const JID&amp; from, ChatStateType state )
        {
            printf( &quot;received state: %d from: %s\n&quot;, state, from.full().c_str() );
        }

        virtual void handleMessageSession( MessageSession *session )
        {
            printf( &quot;got new session\n&quot;);
            if( m_session ) j-&gt;disposeMessageSession( m_session );
            m_session = session;
            m_session-&gt;registerMessageHandler( this );
            m_messageEventFilter = new MessageEventFilter( m_session );
            m_messageEventFilter-&gt;registerMessageEventHandler( this );
            m_chatStateFilter = new ChatStateFilter( m_session );
            m_chatStateFilter-&gt;registerChatStateHandler( this );
        }
        
        //log输出事件，这个事件，在gloox流程中，很多地方都会触发，所以，log信息量会比较大
        virtual void handleLog( LogLevel level, LogArea area, const std::string&amp; message )
        {
            printf(&quot;#-----------#  log: level: %d, area: %d, %s\n&quot;, level, area, message.c_str() );
        }
        
        virtual void onResourceBindError( ResourceBindError error )
        {
            printf( &quot;onResourceBindError: %d\n&quot;, error );
        }

        virtual void onSessionCreateError( SessionCreateError error )
        {
            printf( &quot;onSessionCreateError: %d\n&quot;, error );
        }

    private:
        Client * j;
        MessageSession * m_session;
        MessageEventFilter * m_messageEventFilter;
        ChatStateFilter * m_chatStateFilter;
        MucTest * mt;
};

int main( int argc, char* argv[] )
{
    //测试消息，包括聊天室，文件传输，语音消息，图片等，具体参考消息命令
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}

</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id4">
<h2>Gloox实现场景-群组聊天<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;gloox/gloox.h&quot;
#include &quot;gloox/client.h&quot;
#include &quot;gloox/connectionlistener.h&quot;
#include &quot;gloox/connectiontls.h&quot;
#include &quot;gloox/connectiontlsserver.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/disco.h&quot;
#include &quot;gloox/discohandler.h&quot;
#include &quot;gloox/stanza.h&quot;
#include &quot;gloox/lastactivity.h&quot;
#include &quot;gloox/registration.h&quot;
#include &quot;gloox/logsink.h&quot;
#include &quot;gloox/loghandler.h&quot;

//这部分头文件是关于聊天和注册的
#include &quot;gloox/message.h&quot;
#include &quot;gloox/messagehandler.h&quot;
#include &quot;gloox/messagesessionhandler.h&quot;
#include &quot;gloox/messageeventhandler.h&quot;
#include &quot;gloox/messageeventfilter.h&quot;
#include &quot;gloox/chatstatehandler.h&quot;
#include &quot;gloox/chatstatefilter.h&quot;
#include &quot;gloox/connectiontcpclient.h&quot;
#include &quot;gloox/connectionsocks5proxy.h&quot;
#include &quot;gloox/connectionhttpproxy.h&quot;

//这部分头文件是关于花名册和设置状态，签名（上线，下线，离开等）
#include &quot;gloox/rostermanager.h&quot;
#include &quot;gloox/presence.h&quot;

//这部分头文件是关于会议室的（群组）
#include &quot;gloox/mucroom.h&quot;
#include &quot;gloox/mucroomhandler.h&quot;
#include &quot;gloox/mucinvitationhandler.h&quot;

//这部分头文件是关于修改自己注册信息的
#include &quot;gloox/vcardhandler.h&quot;
#include &quot;gloox/vcardmanager.h&quot;
#include &quot;gloox/vcard.h&quot;

//这部分头文件是关于实现XEP-069扩展
#include &quot;gloox/siprofileft.h&quot;
#include &quot;gloox/siprofilefthandler.h&quot;
#include &quot;gloox/bytestreamdatahandler.h&quot;
#include &quot;gloox/socks5bytestreamserver.h&quot;

#include &quot;gloox/dataform.h&quot;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

//没用其他的数据结构，这里只用了两个命名空间，std和gloox
using namespace std;
using namespace gloox;

//*******************************************************
//gloox一旦实现了继承类，就必须实现这些继承类的virtual接口
//有些接口必须注册（IO里用来通知消息给该接口）
//有的接口则不用注册，在gloox流程分支中会自动触发
//这个功能的实现，主要依靠virtual interface:
//     &quot;handleSubscriptionRequest&quot;
//并注意：该接口原先有BUG，我修改了后可以使用，具体修改原因
//请具体的参考gloox的代码
//*******************************************************

//*******************************************************
//MUC类，也就是会议室功能类
//实现群组聊天必须继承MUC类
//*******************************************************
class MucTest : public MUCRoomHandler, public MUCInvitationHandler
{
    public:
        //构造函数处，这里实现初始化；
        //这里的cli作为参数给了私有成员变量m_client，他是一个client类，在这里用来实现IO
        MucTest(  Client * cli ) : m_room( 0 ), m_client( cli ), MUCInvitationHandler( cli ) {}
    
        virtual ~MucTest() {}
        
        void start()
        {
            //在start方法中，主动建立一个会议室，会议室的资源名称为：glooxMUCtest
            //进入会议室后的别名是ca23
            //XMPP会议室，必须要求具备会议室资源名称，并配置自己的别名
            //资源名称@conference.IP地址/会议室内别名
            JID nick( &quot;glooxMUCtest@conference.192.168.199.225/ca23&quot; );
            m_room = new MUCRoom( m_client, nick, this, 0 );
            //DataForm是Gloox内的一个数据类，里面有一些宏标记，这里我们使用TypeSubmit
            DataForm * df = new DataForm( TypeSubmit );
            //设置标记muc#roomconfig_persistentroom，这个是XMPP XEP标准，含义是永久性会议室
            //XMPP会议室分为两种：临时性，永久性，临时的只要建立用户退出来，会议室自动消失
            df-&gt;addField( DataFormField::TypeBoolean, &quot;muc#roomconfig_persistentroom&quot;, &quot;1&quot;, &quot;Make Room Persistent&quot; );
            m_room-&gt;join();
            m_room-&gt;setRoomConfig(df);
        }
  
        virtual void handleMUCParticipantPresence( MUCRoom * /*room*/, const MUCRoomParticipant participant, const Presence&amp; presence )
        {
            if( presence.presence() == Presence::Available )
                printf( &quot;!!!!!!!!!!!!!!!! %s is in the room, too\n&quot;, participant.nick-&gt;resource().c_str() );
            else if( presence.presence() == Presence::Unavailable )
                printf( &quot;!!!!!!!!!!!!!!!! %s left the room\n&quot;, participant.nick-&gt;resource().c_str() );
            else
                printf( &quot;Presence is %d of %s\n&quot;, presence.presence(), participant.nick-&gt;resource().c_str() );
        }

        //这里获取会议室聊天信息，也就是说，在这里获得群组聊天信息
        virtual void handleMUCMessage( MUCRoom * room, const Message&amp; msg, bool priv )
        {
            printf( &quot;room id %s, %s said: &#39;%s&#39; (history: %s, private: %s)\n&quot;, m_muclist.c_str(), msg.from().resource().c_str(), msg.body().c_str(), msg.when() ? &quot;yes&quot; : &quot;no&quot;, priv ? &quot;yes&quot; : &quot;no&quot; );
        }

        virtual void handleMUCSubject( MUCRoom * /*room*/, const std::string&amp; nick, const std::string&amp; subject )
        {
            if( nick.empty() )
                printf( &quot;Subject: %s\n&quot;, subject.c_str() );
            else
                printf( &quot;%s has set the subject to: &#39;%s&#39;\n&quot;, nick.c_str(), subject.c_str() );
        }

        //这里的错误稍微提一下，常见的错误，有XMPP 400，和XMPP 406
        //400是资源错误，也就是 user@1.2.3.4 后，没有跟随资源，实际应为：user@1.2.3.4/resource
        //resource在不同的XMPP中，会表示不同的作用，在会议室中，他表示昵称
        //406最为常见，是type错误，比如，服务器给你一个groupchat，你回复了一个chat，这就是type错误的一种
        //JID nick( &quot;test@conference.192.168.199.225/glooxmuctest&quot; ); 这就一个完整的例子
        virtual void handleMUCError( MUCRoom * /*room*/, StanzaError error )
        {
            printf( &quot;!!!!!!!!got an error: %d&quot;, error );
        }

        virtual void handleMUCInfo( MUCRoom * /*room*/, int features, const std::string&amp; name, const DataForm* infoForm )
        {
            printf( &quot;features: %d, name: %s, form xml: %s\n&quot;, features, name.c_str(), infoForm-&gt;tag()-&gt;xml().c_str() );
        }

        virtual void handleMUCItems( MUCRoom * /*room*/, const Disco::ItemList&amp; items )
        {
            Disco::ItemList::const_iterator it = items.begin();
            for( ; it != items.end(); ++it )
            {
                printf( &quot;%s -- %s is an item here\n&quot;, (*it)-&gt;jid().full().c_str(), (*it)-&gt;name().c_str() );
            }
        }

        virtual void handleMUCInviteDecline( MUCRoom * /*room*/, const JID&amp; invitee, const std::string&amp; reason )
        {
            printf( &quot;Invitee %s declined invitation. reason given: %s\n&quot;, invitee.full().c_str(), reason.c_str() );
        }

        virtual bool handleMUCRoomCreation( MUCRoom *room )
        {
            printf( &quot;room %s didn&#39;t exist, beeing created.\n&quot;, room-&gt;name().c_str() );
            return true;
        }
        
        //收到了会议室邀请
        //特别提醒一下，这个虚函数handleMUCInvitation在Gloox原版本中，是有bug的，这个函数是我修改之后的版本
        //原版本，会收不到会议邀请
        virtual void handleMUCInvitation( const JID&amp; room, const JID&amp; from, const std::string&amp; reason, const std::string&amp; body, const std::string&amp; password, bool cont, const std::string&amp; thread )
        {
            m_muclist = room.full().c_str();
            printf( &quot;orgi room invict id: %s\n&quot;, room.full().c_str() );
            std::string roomid = room.full().c_str();
            roomid.append(&quot;/ca23&quot;);
            printf( &quot;modify room invict id: %s\n&quot;, roomid.c_str() );
            JID nickmeet( roomid );
            m_room = new MUCRoom( m_client, nickmeet, this, 0 );
            m_room-&gt;join();
            m_room-&gt;getRoomInfo();
            m_room-&gt;getRoomItems();
        }
        
    private:
        MUCRoom * m_room;
        Client * m_client;
        std::string m_muclist;
};



int main( int argc, char* argv[] )
{
    MessageTest * r = new MessageTest();
    r-&gt;start();
    delete( r );

    return 0;
}

</pre></div>
</div>
</div></blockquote>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="openfire_plugin.html">OpenFire 我们可以进行什么样的二次开发？</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, LiuZhuan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>